## 初始需求

我们经常会遇到需要解析命令行参数的场景。如果没有趁手的工具，我们可以自己写一个，自己想办法处理传给main函数的参数。

传入一个程序的参数包含了“标记”（flag）和“值”（value）。标记都是一个字母，前面加上“-”号（例如“-p”这样）。每个标记可以有一个值与之对应，也可以没有对应的值。

我们要开发一个解析器（parser）来处理这些参数。这个解析器需要一个参数结构（schema）来描述“这个程序应该接受哪些参数”的信息，包括：

应该有几个标记
每个标记应该是什么类型
每个标记的缺省值是什么
参数结构指定好以后，就可以把实际接收到的参数列表传给参数解析器。解析器会首先验证参数列表是否与参数结构相匹配。然后，程序就可以向参数解析器查询每个参数的值（根据参数的标记名）。返回值的类型应该与参数结构中规定的类型相一致。

例如，程序接收到的参数是这样：

-l -p 8080 -d /usr/logs

那么对应的参数结构应该规定3个标记：l、p、d

-l（logging，是否记录日志）标记没有与之对应的值，这是一个布尔型的标记，如果传入了“-l”就为True，否则为False。

-p（port，端口号）标记的值是整数型。

-d（directory，目录）标记的值是字符串型。

如果参数结构中规定了的标记在实际的参数列表中没有出现，那么就应该返回合理的缺省值，例如布尔型的缺省值可以是False，数值型的缺省值可以是0，字符串型的缺省值可以是空字符串。

如果实际给出的参数与参数结构不匹配，需要给出良好的错误信息，解释清楚出错的原因。


## 需求分析：

要干什么？处理args的程序

具体要求，分为schema和parser

先说schema，描述“这个程序应该接受哪些参数”
1. 应该有几个 flag
2. 每个 flag 是什么类型
3. 每个 flag 的缺省值是什么
4. flag 由前缀"-"来标记

再说 parser，
1. 接受 schema，以及 args
2. 验证 args 的合法性
  - 无未定义的 flag
  - 第一个参数是 flag
  - flag 后面可以跟 0 或 1 个 value
3. 合法性未通过，则提示错误信息，例如
  - 某个 flag 未在 schema 中定义
  - 某个传入的 value 与 schema 指定的不匹配
4. 合法性通过，提供查询接口
  - 根据 flag 查询 value
  - 返回的类型要与 schema 中指定的一致
  - 如果args未指定 value，返回默认值

## 测试用例

以需求描述的例子来说，接收到的参数是 -l -p 8080 -d /usr/logs

schema
- -l:logging，是否记录日志。类型是布尔
- -p:port，端口号。类型是整数
- -d:directory，目录。类型是字符串

parser

Args: 
解析成功，查询返回标签默认值

Args: -l
解析成功

Args: -l -p 8080 -d /usr/logs
解析成功，查询可以返回正确的value

Args: -p abc
解析失败，参数与标签类型不一致

Args: -p 8080 8081
解析失败，标签后面的参数不是0/1个

Args: -l -p 8080 -d /usr/logs -p 8001
解析失败，重复指定了标签

Args: -l -p 8080 -d /usr/logs -n 
解析失败，指定了未定义的标签